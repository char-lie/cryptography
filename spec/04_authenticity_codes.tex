\chapter{Коды аутентичности сообщений}

Код аутентичности сообщения или имитовставка (message authentication code, MAC)
--- криптопримитив, направленный на защиту целостности конфиденциальных данных,
точнее, выявления их изменений.
MAC-коды аналогичны электронным цифровым подписям, но относятся к классу
симметричных алгоритмов (т.е., для вычисления и проверки имитовставки требуется
один ключ), а потому не обеспечивают аутентификациюю отправителя --- только
аутентификацию данных.

С математической точки зрения MAC-код --- это отображение вида
\begin{equation*}
  mac: \left\{ 0, 1 \right\}^{l\left( n \right)} \times K
  \rightarrow \left\{ 0, 1 \right\}^n,
\end{equation*}
где $k \in K$ --- секретный параметр (ключ), которое удовлетворяет условиям
стойкости к атакам.

\section{Атаки на MAC-коды}
\begin{itemize}
  \item
    Восстановление ключа (key recovery) --- по известному множеству
    \begin{equation*}
      \left( x_i, mac_k\left( x_i \right) \right), i=\overline{1,N}
    \end{equation*}
    восстановить значение ключа $k$ или его части.
    При восстановлении ключа аналитик может в дальнейшем подделывать любую
    подпись
  \item
    Подделка (forgery) --- по известному множеству
    $\left( x_i, mac_k\left( x_i \right) \right), i=\overline{1,N}$
    вычислить правильное значение $y=mac_k\left( x' \right)$ для
    некоторого $x' \notin \left\{ x_i \right\}$
\end{itemize}

Формальные определения стойкости к этим атакам довольно сложны и оперируют
тремя параметрами: время работы противника $T$, вероятность успеха
$\varepsilon$ и размер обучающей выборки $N$.
Мы их не приводим.

\section{Подходы к построению MAC-кодов}
\begin{itemize}
  \item На основе готовых хэш-функций
  \item На основе специальных режимов работы блочных шифров
  \item На основе итеративных конструкций типа схемы Меркле-Дамгора
    --- в первую очередь схема Шупа (Shoup)
  \item На основе комбинаторных универсальных хэш-функций.
    Подход уникальный тем, что определение стойкости не будет зависеть от
    модели вычислений; в прочих аспектах несколько противоречивый.
\end{itemize}

\section{Атака расширения длины (length extension attack)}

Применима к классическим схемам Меркле-Дамгора (с $n=\omega$
и $g\left( x \right) = x$).
К этому типу хэшей относятся $MD5$, $SHA-1$, $SHA-2$, $RIPEMD$
--- то есть все популярные хэш-функции конца XX века.

Пусть $x$ --- сообщение и
$y=mac_k\left( x \right) = h\left( k || x \right)$.
Атакующий формирует сообщение
$x' = x || pad\left( x \right) || z, \forall z$
и вычисляет $y' = mac_k\left( x' \right)$ очень простым образом:
$y' = h\left( z \right)$, если вместо стартового вектора IV взять
значение $y$.

\section{Схемы на основе хэш-функций}

Мы используем хэш-функцию $h\left( x \right)$.

Рассмотрим сначала несколько неочевидно плохих схем:
\begin{enumerate}
  \item $mac_k\left( x \right) = h\left( k || x \right)$

    Эта схема подвержена атакам на структуру итеративной цепи у хэш-функции,
    которые отталкиваются от того, что ключ фактически только задаёт стартовое
    состояние для вычисления хэша от $x$.
  \item $mac_k\left( x \right) = h\left( x || k \right)$

    Эта схема оказалась плоха тем, что ключ влияет только на последние стадии
    вычисления. Значит, если находится коллизия на $X$, она тут же
    превращается в forgery для MAC.
  \item $mac_k\left( x \right) = h\left( k_1 || x || k_2 \right), k=\left( k_1, k_2 \right)$

    Эта схема после тщательного анализа тоже оказалась с уязвимостями
    что при $k_1 = k_2$, что при $k_1 \neq k_2$.
\end{enumerate}

\section{Функция HMAC}

Определена стандартом RFS 2104 ``Keyed-Hashing for Message Authentication''
и включена в ISO.

Как и раньше, $n$ --- длина хэша, $m$ --- размер блока, который обрабатывается
хэш-функцией $h\left( x \right)$.

Ключ $k$ может быть любой длины, но рекомендуется не меньше $n$ бит.
Используется две константы:
\begin{itemize}
  \item $ipad=0x363636\dots 36$ --- байты $0x36$ повторенные столько раз,
    чтобы $\left| ipad \right| = m$
  \item $opad=0x5C5C5C\dots 5C$ --- байты $0x5C$ повторенные столько раз,
    чтобы $\left| opad \right| = m$
\end{itemize}

Вообще говоря, константы могут быть любыми; тут они выбраны так, чтобы
покрыть все биты и по возможности не повторяться.

Вычисление $HMAC$ происходит в два этапа:
\begin{enumerate}
  \item Выравнивание ключа:
    \begin{itemize}
      \item если $\left| k \right| < m$, ключ дополняется нулевыми байтами до
        длины $m$
      \item если $\left| k \right| > m$, то $k = h\left( k \right)$,
        после чего дополняется нулями до длины $m$
    \end{itemize}
    получаем ключ $k$, $\left| k \right| = m$.
  \item Вычисление
    \begin{equation*}
      HMAL_k\left( x \right)
      = h\left( k \mathbin{\oplus}
        || h\left( k \mathbin{\oplus} ipad || x \right) \right)
    \end{equation*}
\end{enumerate}

За счёт того, что используется двойное хэширование и результат
первого недоступен противнику, атаки типа расширения длины перестают работать.

В целом HMAC состоит из одних дотоинств и ровно одного недостатка:
скорость работы (хэши медленные, а тут ещё и два раза).
Блочные шифры в плане скорости выглядят перспективнее.
