\chapter{Современные хэш-функции}

\section{Подходы к построению сжимающей функции}

Сжимающие функции современных хэш-функций строятся:

\begin{itemize}
  \item при помощи блочных шифров (см. ниже)
  \item при помощи поточных шифров --- в первую очередь, из-за скорости
  работы; обычно состояние хэша отождествляется с состоянием поточного
  шифра
  \item при помощи алгебраических операций (modular hashing) --- вызвано
  массовым распостранением аппаратуры, заточенной под RSA, и,
  соответственно, доступностью умножения и возведения в степень по
  модулю
  \item на NP-задачах (задачи на решётках, задачи укладки рюкзака \ldots)
  \item при помощи всякой экзотики (динамических хаос, клеточные
  автоматы, \ldots) \\[0.3cm]
\end{itemize}

\subsection{Схемы на основе блочных шифров}
Рассмотрим блочный шифр
\[ E: \{0,1\}^{m} \times \mathcal{K} \rightarrow \{0,1\}^{m} \]
\[Y = E_{k}(X)\]
\subsubsection{Функция Матяша-Мейера-Озиса (Matyas-Meyer-Oseas)}
\[H_{i} = E_{k(H_{i-1})}(X_{i}) \oplus X_{i}\]
тут $k(H_{i})$ --- преобразование блока $H_{i}$ в ключ шифрования \\[0.1cm]

Считается, что эта функция необратима, но это не доказано. Более того,
непонятно даже, какие требования нужно выдвигать к шифру $E$, чтобы
достигалась стойкость.

Однако Пренель доказал, что можно построить 12 сжимающих функций,
эквивалентных по стойкости функции ММО. Две главные из них:

\begin{description}
  \item[Функция Дэвиса-Мейера (Davis-Mayer)] \hfill \\
  $H_{i} = E_{k(X_{i})}(H_{i-1}) \oplus H_{i-1}$
  \item[Функция Миягути-Пренеля (Miyaguchi-Preneel)] \hfill \\
  $H_{i} = E_{k(H_{i-1})}(X_{i}) \oplus X_{i} \oplus H_{i-1}$
\end{description}

Все указанные функции неявно предполагают, что n = m = $\omega$, т.е., что
размеры блока, состояния и хэша совпадают. Однако размеры блоков современных
шифров (64 и 128 бит) недостаточны для обеспечения стойкости хэш-функции
к атакам общего вида.

Чтобы повысить стойкость и увеличить длину хэша по отношению к размеру
блока шифра, используют более навороченные схемы.\\[0.3cm]

\subsubsection{Функция MDC-2}
--- разработана Брахтом(Bracht), носит также название функции Мейера-Шиллинга
(Meyer-Shilling)\\
--- включена в ISO/IEC 10118-2 как рекомендованная схема

Функция сжатия в MDC-2 имеет вид:\\[0.3cm]
\[(H_{i},\widetilde{H}_{i}) = f(H_{i-1},\widetilde{H}_{i-1}, X_{i})\]
и использует 2 стартовых вектора $H_{0} = IV, \widetilde{H}_{0} = 
\widetilde{IV}$

Хэш-функция MDC-2 = схема MD + описанная функция сжатия.

Самая лучшая из известных атак на MDC-2 требует $O(2^{3m})$ операция для
поиска прообраза и $O(2^{m})$ для поиска коллизии.\footnote{m --- размер
блока шифра, а не хэша}


Однако собственно сжимающая функция в этом плане слабая: требуется
$O(2^{m})$ и $O(2^{m/2})$ операция соответственно.

Этой слабости лишена функция MDC-4, но она ещё более навороченная, 
использует 4 шифра за раунд и потому ещё медленнее.\\[0.5cm]

\subsection{Обобщения схемы Меркле-Дамгора}

Придумано множество вариантов схемы MD, которые убирают те или иные
конструктивные недостатки или защищают от некоторых атак. Рассмотрим
основные из них.

\subsubsection{Концепция wide-pipe ("широкого канала")}
Предложена Люксом (Lucks).

Идея проста: раз уж стойкость хэш-функции сводится к стойкости сжимающей
функции, необходимо сделать часть состояния хэша ненаблюдаемой: $\omega
\geq 2n$. Тогда поиск коллизии для сжимающей функции требует $O(2^{\omega / 2})
= O(2^{n})$ операций --- столько же, сколько и поиск прообраза. Канал
широкий, в конце резко сужается.

Функции с $\omega = n$ стали называть narrow-pipe ("узкий канал")

\subsubsection{Рандомизированное хэширование}
Превращает хэш-функцию в универсальную хэш-функцию. Используется дополнительный
параметр --- "соль" (salt), который должен быть случайным.
\[H_{0} = IV; r = random\]
\[H_{i} = f(H_{i-1}, X_{i} \oplus r), i = \overline{1,t} \]
\[h(X) = (g(H_{t}), r) \]
Рандомизация помогает защититься от атак на основе предвычислений (атаки
компромисса), поскольку значение функции от одинаковых входов будет
всякий раз разное. Стойкость сильно зависит от стойкости используемого ГСЧ.

\subsubsection{Схема HAIFA (HAsh Iterated FrAmework)}
На каждом шаге используется 2 дополнительных параметра:

$s$ --- salt, обеспечивает параметризацию (или рандомизацию); если параметризация
не нужна, то $s$ = 0;

$l_{i}$ --- длина той части входного сообщения, которая обработана на данный
момент, включая блок $X_{i}$ (но без учёта паддинга)

Соответственно,
\[ H_{i} = f(H_{i - 1}, X_{i}, s, l_{i}) \]
Такое простое изменение резко усложнит поиск коллизий за счёт уникальности
обработки каждого блока данных $X_{i}$ в зависимости от позиции i. 
\footnote{Аналогия с полиалфавитными шифрами} Недостаток --- потеря в
вычислительной эффективности (f большого размера и, соответственно, её
вычисление требует больших ресурсов).

На схеме HAIFA построены хэш-функции Blake (финалист SHA-3) и "Стрибог"
(стандарт РФ)

\subsubsection{Хэш-функция Skein}
Один из финалистов конкурса SHA-3, отличается дерзким дизайном :)
\begin{itemize}
  \item используется специально разработанный шифр TreeFish
  \item ARX-дизайн: в вычислениях используються только сложение, xor и
  циклические сдвиги, что приводит к бешенной скорости работы
  \item заточка под 64-битную архитектуру
  \item narrow-pipe (в отличие от всех прочих финалистов SHA-3)
  \item специальный режим работы блочного шифра для хэширования
\end{itemize}

\paragraph{Режим UBI (Unique Block Iteration)}

Главная цель как в и HAIFA --- сделать сжатие каждого блока как можно 
более уникальным
\[H_{i} = E_{k(H_{i-1})}(format(x_{i}, cfg))\]
тут format --- функция форматирования входных данных в битовый блок по размеру входа шифра\\
cfg --- служебные данные, которые включают в себя:
\begin{itemize}
  \item длину обработанного сообщения в байтах(на данный момент)
  \item флаг "это первый блок" (1 бит)
  \item флаг "это последний блок" (1 бит)
  \item флаг "bitpad" (1 бит) --- использовалось ли выравнивание в битах
  \item идентификатор типа хэша (примерно равно salt)
  \item и всё, что пожелает разработчик
\end{itemize}

\subsubsection{Схема Gr{\o}stl}
Хэш-функция Gr{\o}stl --- тоже финалист SHA-3
\begin{itemize}
  \item радикальный wide-pipe
  \item отказ от использования шифров как более уязвимых к атакам на основе неподвижных точек и rebound-атак
\end{itemize}

Внутреннее состояние $\omega \geq 2n$; pad(X) включает длину сообщения.\\
Длина блока сообщения $m = \omega$; используются две перестановки P и Q над $\{0, 1\}^\omega$, которые должны быть "существенно различны"

$H_0 = IV(n)$ (стартовый вектор содержит длину хэша)\\
$H_i = f(H_{i - 1}, X_i), i = \overline{1, t}$\\
$f(h, m) = P(h \oplus m) \oplus Q(m) \oplus h$\\
$h(x) = g(H_t)$\\
$g(h) = trunc_n(P(h) \oplus h)$

Из всех финалистов SHA-3 Gr{\o}stl --- самая консервативная (и надёжная в этом плане)
хэш-функция. Недостаток --- и самая медленная, поскольку требуеются две огромные
перестановки (в самом Gr{\o}stl они реализованы на AES-подобных преобразованиях).

Новый украинский стандарт хэш-функции ДСТУ 7564:2014 ("Купина") построен на схеме Gr{\o}stl\\[0.4cm]

{\large{\bfseries Схема Sponge ("губка")}}\\[0.2cm]

На схеме Sponge основан алгоритм Кессак --- победитель SHA-3
\begin{itemize}
  \item полный отказ от всех существовавших архитектурных решений
  \item ориентация на битовые архитектуры
  \item wide-pipe
  \item использование только простых преобразований (без S-блоков)
  \item переменная длина генерируемого хэша (потенциально до бесконечности)
  \item не требует включения длины сообщения во входной поток (pad)
\end{itemize}

Состояние H разбивается на две части: R (rate --- "такса") --- m бит, и C (capacity --- "ёмкость") --- c бит; $\omega = m + c$

\[H_0 = R_0 || C_0 = 0^\omega\]
\[H_i = R_i || C_i = f(R_{i-1} \oplus X_i || C_i), i = \overline{1, t}\]
\[Z_{i - t} = R_i - 1\]
\[R_i || C_i = f(R_{i - 1} || C_{i - 1})\]
\[h(X) = trunc_n(Z_1 || Z_2 || \ldots )\]

Свойства:

\begin{itemize}
  \item Для Sponge используется фиксированная перестановка f над $\{0, 1\}^\omega$.
В силу сложности построения такой перестановки $\omega$ обычно тоже фиксируют
  \item Чем больше m, тем больше хэш; чем больше C, теб он надёжнее. Разработчики рекомендуют брать $c = 2n$ и $m = \omega - c$.
\footnote{в Keccak $\omega = 1600, c = 2n$, где $n = 128 \ldots 512$}
  \item Единственное требование к паддингу --- входной поток не должен заканчиваться
на серию нулей (иначе, как видно из схемы, возможны атаки на основе удлинения сообщений).
Поэтому разработчики предложили sponge-padding вида pad$(X) = 10\ldots01$
\end{itemize}

Поскольку Sponge генерирует хэш переменной длины, то очевидно, что стандартные методы оценивания стойкости к атакам общего вида (поиск прообраза, дни рождения и т.д.) не подходят
Оказывается, для Sponge параметром стойкости является не длина хэша, а ёмкость.


\newtheorem*{thm}{Теорема}


\begin{thm}
Для Sponge атаки общего вида требуют:\\
--- $O(2^c)$ операций для поиска (второго) прообраза\\
--- $O(2^{c/2})$ операций для поиска коллизии
\end{thm}

Показано, что стойкость Sponge сводится к сложности решения задачи CICO (constrained input, constrained output):\\
пусть $f: \{0, 1\}^N \rightarrow \{0, 1\}^N$ --- биекция, и $X, Y \subseteq\{0,1\}^N$;\\
требуется определить, существует ли $x \in X$ такой, что $f(x) \in Y$.

В общем случае эта задача считается сложной ($\in$ NP). Перестановка f должна выбираться с учётом требования стойкости к этой задаче.



